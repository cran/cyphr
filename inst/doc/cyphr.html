<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Keys and the like</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>This package tries to smooth over some of the differences in
encryption approaches (symmetric vs. asymmetric, sodium vs. openssl)
to provide a simple interface for users who just want to encrypt or
decrypt things.</p>

<p>The scope of the package is to protect data that has been saved to
disk.  It is not designed to stop an attacker targeting the R
process itself to determine the contents of sensitive data.  The
package does try to prevent you accidentally saving to disk the
contents of sensitive information, including the keys that could
decrypt such information.</p>

<p>This vignette works through the basic functionality of the package.
It does not offer much in the way of an introduction to encryption
itself; for that see the excellent vignettes in the <code>openssl</code> and
<code>sodium</code> packages (see <code>vignette(&quot;crypto101&quot;)</code> and
<code>vignette(&quot;bignum&quot;)</code> for information about how encryption works).
This package is a wrapper around those packages in order to make
them more accessible.</p>

<h1>Keys and the like</h1>

<p>To encrypt anything we need a key.  There are two sorts of key
&ldquo;types&rdquo; we will concern ourselves with here &ldquo;symmetric&rdquo; and
&ldquo;asymmetric&rdquo;.</p>

<ul>
<li><p>&ldquo;symmetric&rdquo; keys are used for storing secrets that multiple
people need to access.  Everyone has the same key (which is just
a bunch of bytes) and with that we can either encrypt data or
decrypt it.</p></li>
<li><p>a &ldquo;key pair&rdquo; is a public and a private key; this is used in
communication.  You hold a private key that nobody else ever sees
and a public key that you can copy around all over the show.
These can be used for a couple of different patterns of
communication (see below).</p></li>
</ul>

<p>We support symmetric keys and asymmetric key pairs from the
<code>openssl</code> and <code>sodium</code> packages (which wrap around
industry-standard cryptographic libraries) - this vignette will
show how to create and load keys of different types as they&#39;re
used.</p>

<p>The <code>openssl</code> keys have the advantage of a standard key format, and
that many people (especially on Linux and macOS) have a keypair
already (see below if you&#39;re not sure if you do).  The <code>sodium</code>
keys have the advantage of being a new library, starting from a
clean slate rather than carrying with it accumulated ideas from the
last 20 years of development.</p>

<p>The idea in <code>cyphr</code> is that we can abstract away some differences
in the types of keys and the functions that go with them to create
a standardised interface to encrypting and decrypting strings, R
objects, files and raw vectors.  With that, we can then create
wrappers around functions that create files and simplify the
process of adding encryption into a data workflow.</p>

<p>Below, I&#39;ll describe the sorts of keys that <code>cyphr</code> supports and in
the sections following describe how these can be used to actually
do some encryption.</p>

<h2>Symmetric encryption</h2>

<p>This is the simplest form of encryption because everyone has the
same key (like a key to your house or a single password).  This
raises issues (like how do you <em>store</em> the key without other people
reading it) but we can deal with that below.</p>

<h3><code>openssl</code></h3>

<p>To generate a key with <code>openssl</code>, you can use:</p>

<pre><code class="r">k &lt;- openssl::aes_keygen()
</code></pre>

<p>which generates a raw vector</p>

<pre><code class="r">k
</code></pre>

<pre><code>## aes 7e:d8:b4:57:fe:b0:58:1b:03:26:e3:cf:a8:ca:9b:b8
</code></pre>

<p>(this prints nicely but it really is stored as a 16 byte raw
vector).</p>

<p>The encryption functions that this key supports are
<code>openssl::aes_cbc_encrypt</code>, <code>openssl::aes_ctr_encrypt</code> and
<code>openssl::aes_gcm_encrypt</code> (along with the corresponding decryption
functions).  The <code>cyphr</code> package tries to abstract this away by
using a wrapper cyphr::key_openssl</p>

<pre><code class="r">key &lt;- cyphr::key_openssl(k)
key
</code></pre>

<pre><code>## &lt;cyphr_key: openssl&gt;
</code></pre>

<p>With this key, one can encrypt a string with <code>cyphr::encrypt_string</code>:</p>

<pre><code class="r">secret &lt;- cyphr::encrypt_string(&quot;my secret string&quot;, key)
</code></pre>

<p>and decrypt it again with <code>cyphr::decrypt_string</code>:</p>

<pre><code class="r">cyphr::decrypt_string(secret, key)
</code></pre>

<pre><code>## [1] &quot;my secret string&quot;
</code></pre>

<p>See below for more functions that use these key objects.</p>

<h3><code>sodium</code></h3>

<p>The interface is almost identical using sodium symmetric keys.  To
generate a symmetric key with libsodium you would use
<code>sodium::keygen</code></p>

<pre><code class="r">k &lt;- sodium::keygen()
</code></pre>

<p>This is really just a raw vector of length 32, without even any
class attribute!</p>

<p>The encryption functions that this key supports are
<code>sodium::data_encrypt</code> and <code>sodium::data_decrypt</code>.  To create a key
for use with <code>cyphr</code> that knows this, use:</p>

<pre><code class="r">key &lt;- cyphr::key_sodium(k)
key
</code></pre>

<pre><code>## &lt;cyphr_key: sodium&gt;
</code></pre>

<p>This key can then be used with the high-level cyphr encryption
functions described below.</p>

<h2>Asymmetric encryption (&ldquo;key pairs&rdquo;)</h2>

<p>With asymmetric encryption everybody has two keys that differ from
everyone else&#39;s key.  One key is public and can be shared freely
with anyone you would like to communicate with and the other is
private and must never be disclosed.</p>

<p>In the <code>sodium</code> package there is a vignette
(<code>vignette(&quot;crypto101&quot;)</code>) that gives a gentle introduction to how
this all works.  In practice, you end up creating a pair of keys
for yourself.  Then to encrypt or decrypt something you encrypt
messages with the recipient&#39;s <em>public key</em> and they (and only they)
can decrypt it with their <em>private key</em>.</p>

<p>One use for asymmetric encryption is to encrypt a shared secret
(such as a symmetric key) - with this you can then safely store or
communicate a symmetric key without disclosing it.</p>

<h3><code>openssl</code></h3>

<p>Let&#39;s suppose that we have two parties &ldquo;Alice&rdquo; and &ldquo;Bob&rdquo; who want
to talk with one another.  For demonstration purposes we need to
generate SSH keys (with no password) in temporary directories (to
comply with CRAN policies).  In a real situation these would be on
different machines (Alice has no access to Bob&#39;s key!) and these
keys would be password protected.</p>

<pre><code class="r">path_key_alice &lt;- cyphr::ssh_keygen(password = FALSE)
path_key_bob &lt;- cyphr::ssh_keygen(password = FALSE)
</code></pre>

<p>Note that each directory contains a public key (<code>id_rsa.pub</code>) and a
private key (<code>id_rsa</code>).</p>

<pre><code class="r">dir(path_key_alice)
</code></pre>

<pre><code>## [1] &quot;id_rsa&quot;     &quot;id_rsa.pub&quot;
</code></pre>

<pre><code class="r">dir(path_key_bob)
</code></pre>

<pre><code>## [1] &quot;id_rsa&quot;     &quot;id_rsa.pub&quot;
</code></pre>

<p>Below, the full path to the key (e.g., <code>.../id_rsa</code>) could be
used in place of the directory name if you prefer.</p>

<p>If Alice wants to send a message to Bob she needs to use her
private key and his public key</p>

<pre><code class="r">pair_a &lt;- cyphr::keypair_openssl(path_key_bob, path_key_alice)
pair_a
</code></pre>

<pre><code>## &lt;cyphr_keypair: openssl&gt;
</code></pre>

<p>with this pair she can write a message to &ldquo;bob&rdquo;:</p>

<pre><code class="r">secret &lt;- cyphr::encrypt_string(&quot;secret message&quot;, pair_a)
</code></pre>

<p>The secret is now just a big pile of bytes</p>

<pre><code class="r">secret
</code></pre>

<pre><code>##   [1] 58 0a 00 00 00 03 00 03 06 02 00 03 05 00 00 00 00 05 55 54 46 2d 38 00 00
##  [26] 02 13 00 00 00 04 00 00 00 18 00 00 00 10 65 6d bb 27 55 e5 4e 06 d6 97 3e
##  [51] bc d0 e0 c8 f0 00 00 00 18 00 00 01 00 6f 3f a8 1c b5 92 06 53 18 02 90 0f
##  [76] d1 33 4a d8 71 08 a1 e8 d7 d9 ef 29 5c a6 1a c4 57 6a 01 db a0 22 3d 37 0f
## [101] 0c 60 d7 58 5e 99 ef 53 11 22 d5 6d 74 d6 3a be 59 a4 3d 71 1d 0e 05 c7 db
## [126] a2 d6 27 4d cf e8 ed 2a cd 07 c3 d0 69 d5 69 21 c9 a3 24 ac 45 6f 51 8e b9
## [151] d9 ea 9b 62 4b e4 67 66 93 a3 8f 5e f0 19 2e 4f 36 27 1b 8c e8 87 02 8e 1c
## [176] 46 36 fb b4 08 2d e6 6b 37 78 ff e7 6c 04 9d f5 8e f1 db 80 60 0a 41 0e 1c
## [201] ff eb f3 60 29 37 ed c0 87 0a 9f 49 39 c1 7e 98 3d cf 3a 66 ae e4 cf 8b 5e
## [226] ec a9 49 e8 e3 34 29 b9 d7 32 7d 9b dc b8 85 70 13 65 ea 79 0d 31 45 3c b6
## [251] c1 b5 c2 8e 4d 4c 52 18 da 23 48 64 61 a6 cf 39 63 16 92 9e 38 f4 f8 4a 3c
## [276] 2c 46 24 8a cf e1 e1 76 04 b0 82 d8 c5 98 9b f0 c9 6c 3a eb ae 3b db df 57
## [301] e8 c7 a1 8a 21 5f 1a b6 d8 01 ee 91 09 6e b6 86 38 9d e9 00 00 00 18 00 00
## [326] 00 10 2e cf b2 a1 48 c4 66 5a f8 65 19 62 16 d4 e6 36 00 00 00 18 00 00 01
## [351] 00 2d 64 96 df d1 5a 1a 75 2c a7 0e 71 bf c8 21 53 2d d9 53 d4 48 63 22 07
## [376] a2 e9 e8 90 1f 40 c4 f7 86 13 a9 2b 5f 57 0f 5b 41 f7 f3 bc cf 7d 94 97 5a
## [401] 04 26 3d 58 d3 4b 5f 32 0e fc 2a 4f eb e0 07 4c 93 b5 ad e0 8f 86 59 dd 42
## [426] 14 54 bf dd 3d a1 7c f3 95 f2 fe 1f f8 04 bd 0f 5f 78 ba 99 e2 bc 6c 16 e7
## [451] ab 2b fd 6a d2 ed 3b 45 e2 6c 4a be f6 0e a6 cd 73 73 c5 1b 4d 04 39 ab d0
## [476] fe 67 6d cd ee 96 63 fb e1 4a 3d f4 a0 f4 79 47 2a fc e3 63 81 41 30 8c 91
## [501] 97 26 48 ce 66 0f e4 08 7f 1b 37 86 7a 41 31 b7 a1 37 5f b2 51 c3 00 88 6e
## [526] 9b 59 e6 44 48 8e 4b 8b 8f 4a 6c 7a ea a1 67 8d 35 76 2e c9 6e 32 bc 16 78
## [551] e6 c4 f3 ea ae 52 a9 08 1f 4e fc b1 40 99 a5 a1 9e 26 64 b3 85 0f 6b 0d c2
## [576] 14 bf a9 7a 8d 51 7f dd be f1 54 c2 27 68 53 47 ee 65 c9 a7 eb 33 7e f7 a0
## [601] bc 7b 6a b6 c8 19 d1 00 00 04 02 00 00 00 01 00 04 00 09 00 00 00 05 6e 61
## [626] 6d 65 73 00 00 00 10 00 00 00 04 00 04 00 09 00 00 00 02 69 76 00 04 00 09
## [651] 00 00 00 07 73 65 73 73 69 6f 6e 00 04 00 09 00 00 00 04 64 61 74 61 00 04
## [676] 00 09 00 00 00 09 73 69 67 6e 61 74 75 72 65 00 00 00 fe
</code></pre>

<p>Note that unlike symmetric encryption above, Alice cannot decrypt
her own message:</p>

<pre><code class="r">cyphr::decrypt_string(secret, pair_a)
</code></pre>

<pre><code>## Error: OpenSSL error in RSA_padding_check_PKCS1_type_2: pkcs decoding error
</code></pre>

<p>For Bob to read the message, he uses his private key and Alice&#39;s
public key (which she has transmitted to him previously).</p>

<pre><code class="r">pair_b &lt;- cyphr::keypair_openssl(path_key_alice, path_key_bob)
</code></pre>

<p>With this keypair, Bob can decrypt Alice&#39;s message</p>

<pre><code class="r">cyphr::decrypt_string(secret, pair_b)
</code></pre>

<pre><code>## [1] &quot;secret message&quot;
</code></pre>

<p>And send one back of his own:</p>

<pre><code class="r">secret2 &lt;- cyphr::encrypt_string(&quot;another message&quot;, pair_b)
secret2
</code></pre>

<pre><code>##   [1] 58 0a 00 00 00 03 00 03 06 02 00 03 05 00 00 00 00 05 55 54 46 2d 38 00 00
##  [26] 02 13 00 00 00 04 00 00 00 18 00 00 00 10 44 d8 6f 9d cd d1 80 f6 24 00 a3
##  [51] ed 55 a0 62 e0 00 00 00 18 00 00 01 00 46 45 1e 91 76 aa 7f 1d 32 8d e0 9d
##  [76] 43 10 cb 5a e2 74 e5 65 e9 17 19 17 5c 9e 19 13 24 b1 6b bb 56 17 4d 80 e1
## [101] 33 cb 84 ef 60 f7 5f 4d 17 33 08 7c 51 25 08 8d 49 46 45 b1 ca db 03 a6 12
## [126] 69 8b a5 40 ae a5 c2 88 bc f6 1c 09 36 a2 59 fc 10 48 32 74 28 e9 62 28 41
## [151] 01 b0 8d 18 c2 3f 1d 44 b5 e5 ef 32 e6 54 c8 7d 16 c9 a2 f5 a5 d0 bd 27 4f
## [176] 72 58 08 a1 48 0d 4c 85 cb a4 7f 3c 85 95 78 58 05 91 8a 9c af a1 f7 36 41
## [201] da 30 d3 6b 0c e2 66 a2 7a 10 23 28 d2 87 f4 67 fc 22 a7 54 29 be 19 c4 41
## [226] 6c 0a c6 cc dd ce 08 34 3b 33 c2 02 cc 1f 68 b4 02 b5 2a a6 4c ed 4e 44 17
## [251] f6 53 9e 71 95 0e f0 a6 16 d4 b8 58 9e 0c 50 67 b8 b0 0a c3 8a e4 fa 58 31
## [276] 97 df 20 6b bf 06 51 05 07 17 67 68 d6 53 19 da 4b 9d 0e bb bf 0f 9a c4 99
## [301] 0b a6 79 ca da eb e5 b0 3b c1 75 9a 5d ed c1 66 ce af c3 00 00 00 18 00 00
## [326] 00 10 79 aa 59 a7 ee 58 d1 84 11 33 ca 0b 27 98 26 9d 00 00 00 18 00 00 01
## [351] 00 a5 ad 74 d7 d3 4d 9a cd 57 5c 77 5b 43 1c 29 6c 61 c1 62 cd d7 07 3c 62
## [376] 5a 65 97 71 79 77 a5 54 0b 10 13 24 b9 f1 ee 86 6d af f6 e5 6c 88 73 ef 1c
## [401] 23 86 5e 56 b3 9f 54 84 36 61 54 67 b2 82 21 d2 b2 de 48 e0 b1 9f 5d df 64
## [426] 2b 35 98 23 5c 16 3e f5 0f 27 d1 28 4c d4 95 e1 bc 73 ff 37 1b 46 cd 5c ec
## [451] fe 33 22 e2 c5 51 48 80 3c 8e ca cc 2b c5 4c 7c d6 37 b8 81 ee 19 77 a0 40
## [476] 12 63 84 e7 9b 58 e2 4d eb f5 c3 a2 d8 84 54 d8 ab f7 f4 11 20 54 5c c8 35
## [501] ef 33 cd 18 dd 97 94 17 df 57 72 44 09 ad d4 c8 bc 44 49 c6 98 dd 2f 68 b1
## [526] 0f ee f9 e5 eb e3 51 63 61 3f c3 b4 d7 8c d6 77 4c 33 bc 7b 61 93 55 bb 67
## [551] 49 c7 16 62 d6 1d ce f6 fe e8 85 b4 15 ff 68 d4 67 82 00 3b 97 b6 f2 e3 44
## [576] 2e c3 40 31 4b 0e 70 12 f3 a4 ac 7d e5 ac b2 fe 3b 34 5a a2 fb d3 30 1f 15
## [601] d1 bb 1c 14 7a e4 cd 00 00 04 02 00 00 00 01 00 04 00 09 00 00 00 05 6e 61
## [626] 6d 65 73 00 00 00 10 00 00 00 04 00 04 00 09 00 00 00 02 69 76 00 04 00 09
## [651] 00 00 00 07 73 65 73 73 69 6f 6e 00 04 00 09 00 00 00 04 64 61 74 61 00 04
## [676] 00 09 00 00 00 09 73 69 67 6e 61 74 75 72 65 00 00 00 fe
</code></pre>

<p>which she can decrypt</p>

<pre><code class="r">cyphr::decrypt_string(secret2, pair_a)
</code></pre>

<pre><code>## [1] &quot;another message&quot;
</code></pre>

<p>Chances are, you have an openssl keypair in your <code>.ssh/</code> directory.
If so, you would pass <code>NULL</code> as the path for the private (or less
usefully, the public) key pair part.  So to send a message to Bob,
we&#39;d include the path to Bob&#39;s public key.</p>

<pre><code class="r">pair_us &lt;- cyphr::keypair_openssl(path_key_bob, NULL)
</code></pre>

<p>This all skips over how Alice and Bob will exchange this secret
information.  Because the secret is bytes, it&#39;s a bit odd to work
with.  Alice could save the secret to disk with</p>

<pre><code class="r">secret &lt;- cyphr::encrypt_string(&quot;secret message&quot;, pair_a)
path_for_bob &lt;- file.path(tempdir(), &quot;for_bob_only&quot;)
writeBin(secret, path_for_bob)
</code></pre>

<p>And then send Bob the file <code>for_bob_only</code> (over email or any other
insecure medium).</p>

<p>and bob could read the secret in with:</p>

<pre><code class="r">secret &lt;- readBin(path_for_bob, raw(), file.size(path_for_bob))
cyphr::decrypt_string(secret, pair_b)
</code></pre>

<pre><code>## [1] &quot;secret message&quot;
</code></pre>

<p>As an alternative, you can &ldquo;base64 encode&rdquo; the bytes into something
that you can just email around:</p>

<pre><code class="r">secret_base64 &lt;- openssl::base64_encode(secret)
secret_base64
</code></pre>

<pre><code>## [1] &quot;WAoAAAADAAMGAgADBQAAAAAFVVRGLTgAAAITAAAABAAAABgAAAAQ2z0aUhTVwB59yP/i2nS1tAAAABgAAAEAUzzcgQJ7ZuyzqX01imXp27NCvdGpzeu7akI2wauSBx86qY4v8isAeIr0ac2DRP3XbigklmgYtG1mVxyx8VpF21jjEbuznM4HjOHJ+bgFQbelRPQfozURMfrMN/imelFoh2sYo3XPOCNmshRQqQEOg827pAaG4R0NuAcm6YVOL3ZRvka/xVUHaVHSceIBJ4/MrPoyu10bmm3HCglhJc8NpscpSP7oubXzkOw1/PpKrpuTUVsUJYSaR/zSAM2Uibx+bUyFZGX4mi21am7Gg6VO9vHM9dTShd02rTyQ/YQ1UyU4s3ArBU2rI2rozsbkMljnSP8PfsUHRyuNM0HYVSLnxwAAABgAAAAQDfEVuQIRbbm5OjyUV6Uf4AAAABgAAAEALWSW39FaGnUspw5xv8ghUy3ZU9RIYyIHounokB9AxPeGE6krX1cPW0H387zPfZSXWgQmPVjTS18yDvwqT+vgB0yTta3gj4ZZ3UIUVL/dPaF885Xy/h/4BL0PX3i6meK8bBbnqyv9atLtO0XibEq+9g6mzXNzxRtNBDmr0P5nbc3ulmP74Uo99KD0eUcq/ONjgUEwjJGXJkjOZg/kCH8bN4Z6QTG3oTdfslHDAIhum1nmREiOS4uPSmx66qFnjTV2LsluMrwWeObE8+quUqkIH078sUCZpaGeJmSzhQ9rDcIUv6l6jVF/3b7xVMInaFNH7mXJp+szfvegvHtqtsgZ0QAABAIAAAABAAQACQAAAAVuYW1lcwAAABAAAAAEAAQACQAAAAJpdgAEAAkAAAAHc2Vzc2lvbgAEAAkAAAAEZGF0YQAEAAkAAAAJc2lnbmF0dXJlAAAA/g==&quot;
</code></pre>

<p>This can be converted back with <code>openssl::base64_decode</code>:</p>

<pre><code class="r">identical(openssl::base64_decode(secret_base64), secret)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>Or, less compactly but also suitable for email, you might just
convert the bytes into their hex representation:</p>

<pre><code class="r">secret_hex &lt;- sodium::bin2hex(secret)
secret_hex
</code></pre>

<pre><code>## [1] &quot;580a000000030003060200030500000000055554462d3800000213000000040000001800000010db3d1a5214d5c01e7dc8ffe2da74b5b40000001800000100533cdc81027b66ecb3a97d358a65e9dbb342bdd1a9cdebbb6a4236c1ab92071f3aa98e2ff22b00788af469cd8344fdd76e2824966818b46d66571cb1f15a45db58e311bbb39cce078ce1c9f9b80541b7a544f41fa3351131facc37f8a67a5168876b18a375cf382366b21450a9010e83cdbba40686e11d0db80726e9854e2f7651be46bfc555076951d271e201278fccacfa32bb5d1b9a6dc70a096125cf0da6c72948fee8b9b5f390ec35fcfa4aae9b93515b1425849a47fcd200cd9489bc7e6d4c856465f89a2db56a6ec683a54ef6f1ccf5d4d285dd36ad3c90fd8435532538b3702b054dab236ae8cec6e43258e748ff0f7ec507472b8d3341d85522e7c700000018000000100df115b902116db9b93a3c9457a51fe000000018000001002d6496dfd15a1a752ca70e71bfc821532dd953d448632207a2e9e8901f40c4f78613a92b5f570f5b41f7f3bccf7d94975a04263d58d34b5f320efc2a4febe0074c93b5ade08f8659dd421454bfdd3da17cf395f2fe1ff804bd0f5f78ba99e2bc6c16e7ab2bfd6ad2ed3b45e26c4abef60ea6cd7373c51b4d0439abd0fe676dcdee9663fbe14a3df4a0f479472afce3638141308c91972648ce660fe4087f1b37867a4131b7a1375fb251c300886e9b59e644488e4b8b8f4a6c7aeaa1678d35762ec96e32bc1678e6c4f3eaae52a9081f4efcb14099a5a19e2664b3850f6b0dc214bfa97a8d517fddbef154c227685347ee65c9a7eb337ef7a0bc7b6ab6c819d1000004020000000100040009000000056e616d6573000000100000000400040009000000026976000400090000000773657373696f6e00040009000000046461746100040009000000097369676e6174757265000000fe&quot;
</code></pre>

<p>and the reverse with <code>sodium::hex2bin</code>:</p>

<pre><code class="r">identical(sodium::hex2bin(secret_hex), secret)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>(this is somewhat less space efficient than base64 encoding.</p>

<p>As a final option, you can just save the secret with <code>saveRDS</code> and
read it in with <code>readRDS</code> like any other option.  This will be the
best route if the secret is saved into a more complicated R object
(e.g., a list or <code>data.frame</code>).</p>

<p>See the other cyphr vignette (<code>vignette(&quot;data&quot;, package =
&quot;cyphr&quot;)</code>) for a suggested workflow for exchanging secrets within a
team, and the wrapper functions below for more convenient ways of
working with encrypted data.</p>

<p><strong>Do you already have an ssh keypair?</strong> To find out, run</p>

<pre><code class="r">cyphr::keypair_openssl(NULL, NULL)
</code></pre>

<p>One of three things will happen:</p>

<ol>
<li><p>you will be prompted for your password to decrypt your private
key, and then after entering it an object <code>&lt;cyphr_keypair:
openssl&gt;</code> will be returned - you&#39;re good to go!</p></li>
<li><p>you were <em>not</em> prompted for your password, but got a
<code>&lt;cyphr_keypair: openssl&gt;</code> object.  You should consider whether
this is appropriate and consider generating a new keypair with the
private key encrypted.  If you don&#39;t then anyone who can read your
private key can decrypt any message intended for you.</p></li>
<li><p>you get an error like <code>Did not find default ssh public key at
~/.ssh/id_rsa.pub</code>.  You need to create a keypair.</p></li>
</ol>

<p>To create a keypair, you can use the <code>cyphr::ssh_keygen()</code> function as</p>

<pre><code class="r">cyphr::ssh_keygen(&quot;~/.ssh&quot;)
</code></pre>

<p>This will create the keypair as <code>~/.ssh/id_rsa</code> and
<code>~/.ssh/id_rsa.pub</code>, which is where <code>cyphr</code> will look for your keys
by default.  See <code>?ssh_keygen</code> for more information.  (On Linux and
macOS you might use the <code>ssh-keygen</code> command line utility.  On
windows, PuTTY has a utility for creating keys.)</p>

<h3><code>sodium</code></h3>

<p>With <code>sodium</code>, things are largely the same with the exception that
there is no standard format for saving sodium keys.  The bits below
use an in-memory key (which is just a collection of bytes) but
these can also be filenames, each of which contains the contents of
the key written out with <code>writeBin</code>.</p>

<p>First, generate keys for Alice:</p>

<pre><code class="r">key_a &lt;- sodium::keygen()
pub_a &lt;- sodium::pubkey(key_a)
</code></pre>

<p>the public key is derived from the private key, and Alice can share
that with Bob.  We next generate Bob&#39;s keys</p>

<pre><code class="r">key_b &lt;- sodium::keygen()
pub_b &lt;- sodium::pubkey(key_b)
</code></pre>

<p>Bob would now share is public key with Alice.</p>

<p>If Alice wants to send a message to Bob she again uses her private
key and Bob&#39;s public key:</p>

<pre><code class="r">pair_a &lt;- cyphr::keypair_sodium(pub_b, key_a)
</code></pre>

<p>As above, she can now send a message:</p>

<pre><code class="r">secret &lt;- cyphr::encrypt_string(&quot;secret message&quot;, pair_a)
secret
</code></pre>

<pre><code>##  [1] fa a2 8a 44 71 9c 76 1f 3e 79 d8 4e 1e a8 f0 93 c8 5c df f4 dc ce 61 78 9f
## [26] 21 15 53 09 2f da 8a 8a 38 35 3b 59 7c 8e 11 14 ee 49 e4 f8 b7 1f 8c a8 18
## [51] a7 b8 d7 8c
</code></pre>

<p>Note how this line is identical to the one in the <code>openssl</code> section.</p>

<p>To decrypt this message, Bob would use Alice&#39;s public key and his
private key:</p>

<pre><code class="r">pair_b &lt;- cyphr::keypair_sodium(pub_a, key_b)
cyphr::decrypt_string(secret, pair_b)
</code></pre>

<pre><code>## [1] &quot;secret message&quot;
</code></pre>

<h1>Encrypting things</h1>

<p>Above, we used <code>cyphr::encrypt_string</code> and <code>cyphr::decrypt_string</code>
to encrypt and decrypt a string.  There are several such functions
in the package that encrypt and decrypt</p>

<ul>
<li>R objects <code>encrypt_object</code> / <code>decrypt_object</code> (using serialization
and deserialization)</li>
<li>strings: <code>encrypt_string</code> / <code>decrypt_string</code></li>
<li>raw vectors: <code>encrypt_data</code> / <code>decrypt_data</code></li>
<li>files: <code>encrypt_file</code> / <code>decrypt_file</code></li>
</ul>

<p>For this section we will just use a sodium symmetric encryption
key</p>

<pre><code class="r">key &lt;- cyphr::key_sodium(sodium::keygen())
</code></pre>

<p>For the examples below, in the case of asymmetric encryption (using
either <code>cyphr::keypair_openssl</code> or <code>cyphr::keypair_sodium</code>) the
sender would use their private key and the recipient&#39;s public key
and the recipient would use the complementary key pair.</p>

<h2>Objects</h2>

<p>Here&#39;s an object to encrypt:</p>

<pre><code class="r">obj &lt;- list(x = 1:10, y = &quot;secret&quot;)
</code></pre>

<p>This creates a bunch of raw bytes corresponding to the data (it&#39;s
not really possible to print this as anything nicer than bytes).</p>

<pre><code class="r">secret &lt;- cyphr::encrypt_object(obj, key)
secret
</code></pre>

<pre><code>##   [1] 71 27 35 f7 3f 6d a3 c6 0f 74 58 66 5e 23 4f a4 90 2c 7b 56 c4 e7 de c6 bd
##  [26] ac 72 6f d9 14 6a de 52 d8 6c 58 92 0d d5 07 c5 ab fe e6 60 ac b1 ff 21 e5
##  [51] 0c 5c 33 cc ba 8d d1 dd f6 30 30 19 d6 b9 b8 9a cd c2 8c b3 63 75 33 29 e8
##  [76] 33 9c 28 69 5b 47 d7 69 96 d8 75 3f 64 36 fb a7 e1 c4 b9 ba a3 8e db 76 80
## [101] 5d ff 57 78 31 a6 86 97 70 70 27 18 5f 4b 46 38 e9 ba d2 2b 6a f8 43 34 d2
## [126] fe 5a d1 f7 f9 a4 3f ec f0 04 92 09 dd 9e 55 de ee d8 df 09 ba 16 3a 67 50
## [151] 1d 33 6d da 84 53 c8 3e 15 88 01 8a dd 40 aa 0f 4d a1 67 01 78 fd f4 32 00
## [176] 37 23 ff 9c 73 16 a6 22 b5 f7 de 92 a2 a1 27 74 ea fa 18 ca 5b 83 56 61 1b
## [201] e1 0b 5a 21 00 8c 81 8a 71 02 54 c4 c1 61 f6 d0 26 98 96 d1 d8 06 92 d1 5d
## [226] e5 04 e0 84 01 99 c3 be 3d 61 e8 fb 45 e7 94 82 33 4e d4 16 d3 07 b0 7d 16
## [251] fa db 82 f4
</code></pre>

<p>The data can be decrypted with the <code>decrypt_object</code> function:</p>

<pre><code class="r">cyphr::decrypt_object(secret, key)
</code></pre>

<pre><code>## $x
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## $y
## [1] &quot;secret&quot;
</code></pre>

<p>Optionally, this process can go via a file, using a third argument
to the functions (note that temporary files are used here for
compliance with CRAN policies - any path may be used in practice).</p>

<pre><code class="r">path_secret &lt;- file.path(tempdir(), &quot;secret.rds&quot;)
cyphr::encrypt_object(obj, key, path_secret)
</code></pre>

<p>There is now a file called <code>secret.rds</code> in the temporary directory:</p>

<pre><code class="r">file.exists(path_secret)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>though it is not actually an rds file:</p>

<pre><code class="r">readRDS(path_secret)
</code></pre>

<pre><code>## Error in readRDS(path_secret): unknown input format
</code></pre>

<p>When passed a filename (as opposed to a raw vector),
<code>cyphr::decrypt_object</code> will read the object in before decrypting
it</p>

<pre><code class="r">cyphr::decrypt_object(path_secret, key)
</code></pre>

<pre><code>## $x
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## $y
## [1] &quot;secret&quot;
</code></pre>

<h2>Strings</h2>

<p>For the case of strings we can do this in a slightly more
lightweight way (the above function routes through <code>serialize</code> /
<code>deserialize</code> which can be slow and will create larger objects than
using <code>charToRaw</code> / <code>rawToChar</code>)</p>

<pre><code class="r">secret &lt;- cyphr::encrypt_string(&quot;secret&quot;, key)
secret
</code></pre>

<pre><code>##  [1] c0 9d 6d 74 fd dc 99 86 a7 1e c0 88 4a 60 87 9a 69 6f 5c 57 5d f5 49 7e 21
## [26] 08 5b 9a e4 5c 9f f4 3c 1e 86 33 a2 e8 79 02 58 c1 01 d5 59 7c
</code></pre>

<p>and decrypt:</p>

<pre><code class="r">cyphr::decrypt_string(secret, key)
</code></pre>

<pre><code>## [1] &quot;secret&quot;
</code></pre>

<h2>Plain raw data</h2>

<p>If these are not enough for you, you can work directly with raw
objects (bunches of bytes) by using <code>encrypt_data</code>:</p>

<pre><code class="r">dat &lt;- sodium::random(100)
dat # some random bytes
</code></pre>

<pre><code>##   [1] 73 cb fb a5 f8 2c cb d0 f4 7a ad 6c a9 af 9d 82 cd ea 0b 48 1b 41 a7 8a 64
##  [26] be bb a9 2d 16 20 d5 8d 4d 79 a2 cc bb 26 f1 15 02 5f c6 dd 58 67 fe 13 63
##  [51] 57 93 bb 35 d0 e5 77 55 74 55 b6 51 e5 54 e8 02 d0 2f e7 6b d1 8a db a4 36
##  [76] 4e 2e 42 ab e1 0f 66 c7 75 8b f5 4d ac c2 4b 38 2f e9 11 8e 1d b1 13 ed c9
</code></pre>

<pre><code class="r">secret &lt;- cyphr::encrypt_data(dat, key)
secret
</code></pre>

<pre><code>##   [1] 0f 7c 89 ad ff 38 ab 08 f7 de f1 0f 09 e0 47 2f fb 9e 40 b1 a9 06 f4 1c 1a
##  [26] 94 a1 a0 b1 5d b9 69 16 95 cf 67 40 6b 94 f7 1f db f4 56 e3 52 04 0e 92 7d
##  [51] 3d 20 1d 27 9d ea 60 03 5b 80 80 45 da 3e 0f 61 41 a1 09 a2 81 1e b5 64 7a
##  [76] 9d 28 97 eb 95 c3 cf 59 64 a3 01 77 f1 b1 98 23 88 2e e4 9f a2 47 3a d9 3f
## [101] 72 f1 de 06 87 78 9d 9f ff 5e e4 3e 3a 59 be 5c 76 4a c4 0e 2d 68 59 7d 44
## [126] 3c 85 27 6f 46 1d 62 57 56 e9 b3 8e ea e8 2e
</code></pre>

<p>Decrypted data is the same as a the original data</p>

<pre><code class="r">identical(cyphr::decrypt_data(secret, key), dat)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h2>Files</h2>

<p>Suppose we have written a file that we want to encrypt to send to
someone (in a temporary directory for compliance with CRAN
policies)</p>

<pre><code class="r">path_data_csv &lt;- file.path(tempdir(), &quot;iris.csv&quot;)
write.csv(iris, path_data_csv, row.names = FALSE)
</code></pre>

<p>You can encrypt that file with</p>

<pre><code class="r">path_data_enc &lt;- file.path(tempdir(), &quot;iris.csv.enc&quot;)
cyphr::encrypt_file(path_data_csv, key, path_data_enc)
</code></pre>

<p>This encrypted file can then be decrypted with</p>

<pre><code class="r">path_data_decrypted &lt;- file.path(tempdir(), &quot;idis2.csv&quot;)
cyphr::decrypt_file(path_data_enc, key, path_data_decrypted)
</code></pre>

<p>Which is identical to the original:</p>

<pre><code class="r">tools::md5sum(c(path_data_csv, path_data_decrypted))
</code></pre>

<pre><code>##           /tmp/RtmpYBipYM/iris.csv          /tmp/RtmpYBipYM/idis2.csv 
## &quot;5fe92fe6a2c1928ef5a67b8939fdaf8d&quot; &quot;5fe92fe6a2c1928ef5a67b8939fdaf8d&quot;
</code></pre>

<h1>An even higher level interface for files</h1>

<p>This is the most user-friendly way of using the package when the
aim is to encrypt and decrypt files.  The package provides a pair
of functions <code>cyphr::encrypt</code> and <code>cyphr::decrypt</code> that wrap file
writing and file reading functions.  In general you would use
<code>encrypt</code> when writing a file and <code>decrypt</code> when reading one.
They&#39;re designed to be used like so:</p>

<p>Suppose you have a super-secret object that you want to share privately</p>

<pre><code class="r">key &lt;- cyphr::key_sodium(sodium::keygen())
x &lt;- list(a = 1:10, b = &quot;don&#39;t tell anyone else&quot;)
</code></pre>

<p>If you save <code>x</code> to disk with <code>saveRDS</code> it will be readable by
everyone until it is deleted.  But if you encrypted the file that
<code>saveRDS</code> produced it would be protected and only people with the
key can read it:</p>

<pre><code class="r">path_object &lt;- file.path(tempdir(), &quot;secret.rds&quot;)
cyphr::encrypt(saveRDS(x, path_object), key)
</code></pre>

<p>(see below for some more details on how this works).</p>

<p>This file cannot be read with <code>readRDS</code>:</p>

<pre><code class="r">readRDS(path_object)
</code></pre>

<pre><code>## Error in readRDS(path_object): unknown input format
</code></pre>

<p>but if we wrap the call with <code>decrypt</code> and pass in the config
object it can be decrypted and read:</p>

<pre><code class="r">cyphr::decrypt(readRDS(path_object), key)
</code></pre>

<pre><code>## $a
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## $b
## [1] &quot;don&#39;t tell anyone else&quot;
</code></pre>

<p>What happens in the call above is <code>cyphr</code> uses &ldquo;non standard
evaluation&rdquo; to rewrite the call above so that it becomes
(approximately)</p>

<ol>
<li>use <code>cyphr::decrypt_file</code> to decrypt &ldquo;secret.rds&rdquo; as a temporary file</li>
<li>call <code>readRDS</code> on that temporary file</li>
<li>delete the temporary file (even if there is an error in the above calls)</li>
</ol>

<p>This non-standard evaluation breaks referential integrity (so may
not be suitable for programming).  You can always do this manually
with <code>encrypt_file</code> / <code>decrypt_file</code> so long as you make sure to
clean up after yourself.</p>

<p>The <code>encrypt</code> function inspects the call in the first argument
passed to it and works out for the function provided (<code>saveRDS</code>)
which argument corresponds to the filename (here <code>&quot;secret.rds&quot;</code>).
It then rewrites the call to write out to a temporary file (using
<code>tempfile()</code>).  Then it calls <code>encrypt_file</code> (see below) on this
temporary file to create the file asked for (<code>&quot;secret.rds&quot;</code>).  Then
it deletes the temporary file, though this will also happen in case
of an error in any of the above.</p>

<p>The <code>decrypt</code> function works similarly.  It inspects the call and
detects that the first argument represents the filename.  It
decrypts that file to create a temporary file, and then runs
<code>readRDS</code> on that file.  Again it will delete the temporary file on
exit.</p>

<p>The functions supported via this interface are:</p>

<ul>
<li><code>readLines</code> / <code>writeLines</code></li>
<li><code>readRDS</code> / <code>writeRDS</code></li>
<li><code>read</code> / <code>save</code></li>
<li><code>read.table</code> / <code>write.table</code></li>
<li><code>read.csv</code> / <code>read.csv2</code> / <code>write.csv</code></li>
<li><code>read.delim</code> / <code>read.delim2</code></li>
</ul>

<p>But new functions can be added with the <code>rewrite_register</code>
function.  For example, to support the excellent
<a href="https://cran.r-project.org/package=rio">rio</a> package, whose
<code>import</code> and <code>export</code> functions take the filename <code>file</code> you could
use:</p>

<pre><code class="r">cyphr::rewrite_register(&quot;rio&quot;, &quot;import&quot;, &quot;file&quot;)
cyphr::rewrite_register(&quot;rio&quot;, &quot;export&quot;, &quot;file&quot;)
</code></pre>

<p>now you can read and write tabular data into and out of a great
many different file formats with encryption with calls like</p>

<pre><code class="r">cyphr::encrypt(rio::export(mtcars, &quot;file.json&quot;), key)
cyphr::decrypt(rio::import(&quot;file.json&quot;), key)
</code></pre>

<p>The functions above use <a href="http://adv-r.had.co.nz/Computing-on-the-language.html">non standard evaluation</a>
and so may not be suitable for programming or use in packages.  An
&ldquo;escape hatch&rdquo; is provided via <code>encrypt_</code> and <code>decrypt_</code> where the
first argument is a quoted expression.</p>

<pre><code class="r">cyphr::encrypt_(quote(saveRDS(x, path_object)), key)
cyphr::decrypt_(quote(readRDS(path_object)), key)
</code></pre>

<pre><code>## $a
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## $b
## [1] &quot;don&#39;t tell anyone else&quot;
</code></pre>

<h1>Session keys</h1>

<p>When using <code>key_openssl</code>, <code>keypair_openssl</code>, <code>key_sodium</code>, or
<code>keypair_sodium</code> we generate something that can decrypt data.  The
objects that are returned by these functions can encrypt and
decrypt data and so it is reasonable to be concerned that if these
objects were themselves saved to disk your data would be
compromised.</p>

<p>To avoid this, <code>cyphr</code> does not store private or symmetric keys
directly in these objects but instead encrypts the sensitive keys
with a <code>cyphr</code>-specific session key that is regenerated each time
the package is loaded.  This means that the objects are practically
only useful within one session, and if saved with <code>save.image</code>
(perhaps automatically at the end of a session) the keys cannot be
used to decrypt data.</p>

<p>To manually invalidate all keys you can use the
<code>cyphr::session_key_refresh</code> function.  For example, here is a
symmetric key:</p>

<pre><code class="r">key &lt;- cyphr::key_sodium(sodium::keygen())
</code></pre>

<p>which we can use to encrypt a secret string</p>

<pre><code class="r">secret &lt;- cyphr::encrypt_string(&quot;my secret&quot;, key)
</code></pre>

<p>and decrypt it:</p>

<pre><code class="r">cyphr::decrypt_string(secret, key)
</code></pre>

<pre><code>## [1] &quot;my secret&quot;
</code></pre>

<p>If we refresh the session key we invalidate the <code>key</code> object</p>

<pre><code class="r">cyphr::session_key_refresh()
</code></pre>

<p>and after this point the key cannot be used any further</p>

<pre><code class="r">cyphr::decrypt_string(secret, key)
</code></pre>

<pre><code>## Error: Failed to decrypt key as session key has changed
</code></pre>

<p>This approach works because the package holds the session key
within its environment (in <code>cyphr:::session$key</code>) which R will not
serialize.  As noted above - this approach does not prevent an
attacker with the ability to snoop on your R session from
discovering your private keys or sensitive data but it does prevent
accidentally saving keys in a way that would be useful for an
attacker to use in a subsequent session.</p>

<h1>Further reading</h1>

<ul>
<li>The wikipedia page on Public Key cryptography has some nice
diagrams that explain how key and data interact
<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">https://en.wikipedia.org/wiki/Public-key_cryptography</a></li>
<li>The vignettes in the <code>openssl</code> (<code>vignette(package = &quot;openssl&quot;)</code>)
and <code>sodium</code> (<code>vignette(package = &quot;openssl&quot;)</code>) packages have
explanations of how the tools used in <code>cyphr</code> work and interface
with R.</li>
</ul>

<p>Confused?  Need help?  Found a bug?</p>

<ul>
<li>Post an issue on the <a href="https://github.com/ropensci/cyphr/issues"><code>cyphr</code> issue
tracker</a></li>
<li>Start a discussion on the <a href="https://discuss.ropensci.org/">rOpenSci discussion
forum</a></li>
</ul>

</body>

</html>
